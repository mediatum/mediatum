From b24ba691c54a4148677979d00e911cba5215bd62 Mon Sep 17 00:00:00 2001
From: congkhacdung <dung.cong-khac@ub.tum.de>
Date: Thu, 7 Jan 2021 06:47:25 +0000
Subject: [PATCH] Diff between ianare/EXIF.py and lib/Exif/EXIF.py

---
 EXIF.py | 386 ++++++++++++++++++++++++----------------------------------------
 1 file changed, 145 insertions(+), 241 deletions(-)

diff --git a/EXIF.py b/EXIF.py
index b777db8..f0dc5f1 100755
--- a/EXIF.py
+++ b/EXIF.py
@@ -1269,23 +1269,23 @@ class EXIF_header:
     # start of the EXIF information.  For some cameras that use relative tags,
     # this offset may be relative to some other starting point.
     def s2n(self, offset, length, signed=0):
-        self.file.seek(self.offset+offset)
-        slice=self.file.read(length)
+        self.file.seek(self.offset + offset)
+        slice = self.file.read(length)
         if self.endian == 'I':
-            val=s2n_intel(slice)
+            val = s2n_intel(slice)
         else:
-            val=s2n_motorola(slice)
+            val = s2n_motorola(slice)
         # Sign extension ?
         if signed:
-            msb=1L << (8*length-1)
+            msb = 1L << (8 * length - 1)
             if val & msb:
-                val=val-(msb << 1)
+                val = val - (msb << 1)
         return val
 
     # convert offset to string
     def n2s(self, offset, length):
         s = ''
-        for dummy in range(length):
+        for i in range(length):
             if self.endian == 'I':
                 s = s + chr(offset & 0xFF)
             else:
@@ -1299,142 +1299,97 @@ class EXIF_header:
 
     # return pointer to next IFD
     def next_IFD(self, ifd):
-        entries=self.s2n(ifd, 2)
-        next_ifd = self.s2n(ifd+2+12*entries, 4)
-        if next_ifd == ifd:
-            return 0
-        else:
-            return next_ifd
+        entries = self.s2n(ifd, 2)
+        return self.s2n(ifd + 2 + 12 * entries, 4)
 
     # return list of IFDs in header
     def list_IFDs(self):
-        i=self.first_IFD()
-        a=[]
+        i = self.first_IFD()
+        a = []
         while i:
             a.append(i)
-            i=self.next_IFD(i)
+            i = self.next_IFD(i)
         return a
 
     # return list of entries in this IFD
-    def dump_IFD(self, ifd, ifd_name, dict=EXIF_TAGS, relative=0, stop_tag='UNDEF'):
-        entries=self.s2n(ifd, 2)
+    def dump_IFD(self, ifd, ifd_name, dict=EXIF_TAGS, relative=0):
+        entries = self.s2n(ifd, 2)
         for i in range(entries):
             # entry is index of start of this IFD in the file
             entry = ifd + 2 + 12 * i
             tag = self.s2n(entry, 2)
-
-            # get tag name early to avoid errors, help debug
+            # get tag name.  We do it early to make debugging easier
             tag_entry = dict.get(tag)
             if tag_entry:
                 tag_name = tag_entry[0]
             else:
                 tag_name = 'Tag 0x%04X' % tag
-
-            # ignore certain tags for faster processing
-            if not (not detailed and tag in IGNORE_TAGS):
-                field_type = self.s2n(entry + 2, 2)
-                
+            field_type = self.s2n(entry + 2, 2)
+            if not 0 < field_type < len(FIELD_TYPES):
                 # unknown field type
-                if not 0 < field_type < len(FIELD_TYPES):
-                    if not self.strict:
-                        continue
-                    else:
-                        raise ValueError('unknown type %d in tag 0x%04X' % (field_type, tag))
-
-                typelen = FIELD_TYPES[field_type][0]
-                count = self.s2n(entry + 4, 4)
-                # Adjust for tag id/type/count (2+2+4 bytes)
-                # Now we point at either the data or the 2nd level offset
-                offset = entry + 8
-
-                # If the value fits in 4 bytes, it is inlined, else we
-                # need to jump ahead again.
-                if count * typelen > 4:
-                    # offset is not the value; it's a pointer to the value
-                    # if relative we set things up so s2n will seek to the right
-                    # place when it adds self.offset.  Note that this 'relative'
-                    # is for the Nikon type 3 makernote.  Other cameras may use
-                    # other relative offsets, which would have to be computed here
-                    # slightly differently.
-                    if relative:
-                        tmp_offset = self.s2n(offset, 4)
-                        offset = tmp_offset + ifd - 8
-                        if self.fake_exif:
-                            offset = offset + 18
-                    else:
-                        offset = self.s2n(offset, 4)
-
-                field_offset = offset
-                if field_type == 2:
-                    # special case: null-terminated ASCII string
-                    # XXX investigate
-                    # sometimes gets too big to fit in int value
-                    if count != 0 and count < (2**31):
-                        self.file.seek(self.offset + offset)
-                        values = self.file.read(count)
-                        #print values
-                        # Drop any garbage after a null.
-                        values = values.split('\x00', 1)[0]
-                    else:
-                        values = ''
+                raise ValueError('unknown type %d in tag 0x%04X' % (field_type, tag))
+            typelen = FIELD_TYPES[field_type][0]
+            count = self.s2n(entry + 4, 4)
+            offset = entry + 8
+            if count * typelen > 4:
+                # offset is not the value; it's a pointer to the value
+                # if relative we set things up so s2n will seek to the right
+                # place when it adds self.offset.  Note that this 'relative'
+                # is for the Nikon type 3 makernote.  Other cameras may use
+                # other relative offsets, which would have to be computed here
+                # slightly differently.
+                if relative:
+                    tmp_offset = self.s2n(offset, 4)
+                    offset = tmp_offset + ifd - self.offset + 4
+                    if self.fake_exif:
+                        offset = offset + 18
                 else:
-                    values = []
-                    signed = (field_type in [6, 8, 9, 10])
-                    
-                    # XXX investigate
-                    # some entries get too big to handle could be malformed
-                    # file or problem with self.s2n
-                    if count < 1000:
-                        for dummy in range(count):
-                            if field_type in (5, 10):
-                                # a ratio
-                                value = Ratio(self.s2n(offset, 4, signed),
-                                              self.s2n(offset + 4, 4, signed))
-                            else:
-                                value = self.s2n(offset, typelen, signed)
-                            values.append(value)
-                            offset = offset + typelen
-                    # The test above causes problems with tags that are 
-                    # supposed to have long values!  Fix up one important case.
-                    elif tag_name == 'MakerNote' :
-                        for dummy in range(count):
-                            value = self.s2n(offset, typelen, signed)
-                            values.append(value)
-                            offset = offset + typelen
-                    #else :
-                    #    print "Warning: dropping large tag:", tag, tag_name
-                
-                # now 'values' is either a string or an array
-                if count == 1 and field_type != 2:
-                    printable=str(values[0])
-                elif count > 50 and len(values) > 20 :
-                    printable=str( values[0:20] )[0:-1] + ", ... ]"
+                    offset = self.s2n(offset, 4)
+            field_offset = offset
+            if field_type == 2:
+                # special case: null-terminated ASCII string
+                if count != 0:
+                    self.file.seek(self.offset + offset)
+                    values = self.file.read(count)
+                    values = values.strip().replace('\x00', '')
                 else:
-                    printable=str(values)
-
-                # compute printable version of values
-                if tag_entry:
-                    if len(tag_entry) != 1:
-                        # optional 2nd tag element is present
-                        if callable(tag_entry[1]):
-                            # call mapping function
-                            printable = tag_entry[1](values)
-                        else:
-                            printable = ''
-                            for i in values:
-                                # use lookup table for this tag
-                                printable += tag_entry[1].get(i, repr(i))
-
-                self.tags[ifd_name + ' ' + tag_name] = IFD_Tag(printable, tag,
-                                                          field_type,
-                                                          values, field_offset,
-                                                          count * typelen)
-                if self.debug:
-                    print ' debug:   %s: %s' % (tag_name,
-                                                repr(self.tags[ifd_name + ' ' + tag_name]))
-
-            if tag_name == stop_tag:
-                break
+                    values = ''
+            else:
+                values = []
+                signed = (field_type in [6, 8, 9, 10])
+                for j in range(count):
+                    if field_type in (5, 10):
+                        # a ratio
+                        value_j = Ratio(self.s2n(offset,   4, signed),
+                                        self.s2n(offset + 4, 4, signed))
+                    else:
+                        value_j = self.s2n(offset, typelen, signed)
+                    values.append(value_j)
+                    offset = offset + typelen
+            # now "values" is either a string or an array
+            if count == 1 and field_type != 2:
+                printable = str(values[0])
+            else:
+                printable = str(values)
+            # compute printable version of values
+            if tag_entry:
+                if len(tag_entry) != 1:
+                    # optional 2nd tag element is present
+                    if callable(tag_entry[1]):
+                        # call mapping function
+                        printable = tag_entry[1](values)
+                    else:
+                        printable = ''
+                        for i in values:
+                            # use lookup table for this tag
+                            printable += tag_entry[1].get(i, repr(i))
+            self.tags[ifd_name + ' ' + tag_name] = IFD_Tag(printable, tag,
+                                                           field_type,
+                                                           values, field_offset,
+                                                           count * typelen)
+            if self.debug:
+                print ' debug:   %s: %s' % (tag_name,
+                                            repr(self.tags[ifd_name + ' ' + tag_name]))
 
     # extract uncompressed TIFF thumbnail (like pulling teeth)
     # we take advantage of the pre-existing layout in the thumbnail IFD as
@@ -1447,17 +1402,17 @@ class EXIF_header:
         else:
             tiff = 'II*\x00\x08\x00\x00\x00'
         # ... plus thumbnail IFD data plus a null "next IFD" pointer
-        self.file.seek(self.offset+thumb_ifd)
-        tiff += self.file.read(entries*12+2)+'\x00\x00\x00\x00'
+        self.file.seek(self.offset + thumb_ifd)
+        tiff += self.file.read(entries * 12 + 2) + '\x00\x00\x00\x00'
 
         # fix up large value offset pointers into data area
         for i in range(entries):
             entry = thumb_ifd + 2 + 12 * i
             tag = self.s2n(entry, 2)
-            field_type = self.s2n(entry+2, 2)
+            field_type = self.s2n(entry + 2, 2)
             typelen = FIELD_TYPES[field_type][0]
-            count = self.s2n(entry+4, 4)
-            oldoff = self.s2n(entry+8, 4)
+            count = self.s2n(entry + 4, 4)
+            oldoff = self.s2n(entry + 8, 4)
             # start of the 4-byte pointer area in entry
             ptr = i * 12 + 18
             # remember strip offsets location
@@ -1469,7 +1424,7 @@ class EXIF_header:
                 # update offset pointer (nasty "strings are immutable" crap)
                 # should be able to say "tiff[ptr:ptr+4]=newoff"
                 newoff = len(tiff)
-                tiff = tiff[:ptr] + self.n2s(newoff, 4) + tiff[ptr+4:]
+                tiff = tiff[:ptr] + self.n2s(newoff, 4) + tiff[ptr + 4:]
                 # remember strip offsets location
                 if tag == 0x0111:
                     strip_off = newoff
@@ -1513,34 +1468,27 @@ class EXIF_header:
     # or from the header at the start of the makernote.)
     def decode_maker_note(self):
         note = self.tags['EXIF MakerNote']
-        
-        # Some apps use MakerNote tags but do not use a format for which we
-        # have a description, so just do a raw dump for these.
-        #if self.tags.has_key('Image Make'):
         make = self.tags['Image Make'].printable
-        #else:
-        #    make = ''
-
-        # model = self.tags['Image Model'].printable # unused
+        model = self.tags['Image Model'].printable
 
         # Nikon
         # The maker note usually starts with the word Nikon, followed by the
         # type of the makernote (1 or 2, as a short).  If the word Nikon is
         # not at the start of the makernote, it's probably type 2, since some
         # cameras work that way.
-        if 'NIKON' in make:
-            if note.values[0:7] == [78, 105, 107, 111, 110, 0, 1]:
+        if make in ('NIKON', 'NIKON CORPORATION'):
+            if note.values[0:7] == [78, 105, 107, 111, 110, 00, 01]:
                 if self.debug:
                     print "Looks like a type 1 Nikon MakerNote."
-                self.dump_IFD(note.field_offset+8, 'MakerNote',
+                self.dump_IFD(note.field_offset + 8, 'MakerNote',
                               dict=MAKERNOTE_NIKON_OLDER_TAGS)
-            elif note.values[0:7] == [78, 105, 107, 111, 110, 0, 2]:
+            elif note.values[0:7] == [78, 105, 107, 111, 110, 00, 02]:
                 if self.debug:
                     print "Looks like a labeled type 2 Nikon MakerNote"
                 if note.values[12:14] != [0, 42] and note.values[12:14] != [42L, 0L]:
                     raise ValueError("Missing marker tag '42' in MakerNote.")
                 # skip the Makernote label and the TIFF header
-                self.dump_IFD(note.field_offset+10+8, 'MakerNote',
+                self.dump_IFD(note.field_offset + 10 + 8, 'MakerNote',
                               dict=MAKERNOTE_NIKON_NEWER_TAGS, relative=1)
             else:
                 # E99x or D1
@@ -1551,16 +1499,13 @@ class EXIF_header:
             return
 
         # Olympus
-        if make.startswith('OLYMPUS'):
-            self.dump_IFD(note.field_offset+8, 'MakerNote',
+        if make[:7] == 'OLYMPUS':
+            self.dump_IFD(note.field_offset + 8, 'MakerNote',
                           dict=MAKERNOTE_OLYMPUS_TAGS)
-            # XXX TODO
-            #for i in (('MakerNote Tag 0x2020', MAKERNOTE_OLYMPUS_TAG_0x2020),):
-            #    self.decode_olympus_tag(self.tags[i[0]].values, i[1])
-            #return
+            return
 
         # Casio
-        if 'CASIO' in make or 'Casio' in make:
+        if make == 'Casio':
             self.dump_IFD(note.field_offset, 'MakerNote',
                           dict=MAKERNOTE_CASIO_TAGS)
             return
@@ -1588,63 +1533,54 @@ class EXIF_header:
                           dict=MAKERNOTE_CANON_TAGS)
             for i in (('MakerNote Tag 0x0001', MAKERNOTE_CANON_TAG_0x001),
                       ('MakerNote Tag 0x0004', MAKERNOTE_CANON_TAG_0x004)):
-                if i[0] in self.tags:
-                   self.canon_decode_tag(self.tags[i[0]].values, i[1])
+                self.canon_decode_tag(self.tags[i[0]].values, i[1])
             return
 
-
-    # XXX TODO decode Olympus MakerNote tag based on offset within tag
-    def olympus_decode_tag(self, value, dict):
-        pass
-
     # decode Canon MakerNote tag based on offset within tag
     # see http://www.burren.cx/david/canon.html by David Burren
     def canon_decode_tag(self, value, dict):
         for i in range(1, len(value)):
-            x=dict.get(i, ('Unknown', ))
+            x = dict.get(i, ('Unknown', ))
             if self.debug:
                 print i, x
-            name=x[0]
+            name = x[0]
             if len(x) > 1:
-                val=x[1].get(value[i], 'Unknown')
+                val = x[1].get(value[i], 'Unknown')
             else:
-                val=value[i]
+                val = value[i]
             # it's not a real IFD Tag but we fake one to make everybody
             # happy. this will have a "proprietary" type
-            self.tags['MakerNote '+name]=IFD_Tag(str(val), None, 0, None,
-                                                 None, None)
+            self.tags['MakerNote ' + name] = IFD_Tag(str(val), None, 0, None,
+                                                     None, None)
 
 # process an image file (expects an open file object)
 # this is the function that has to deal with all the arbitrary nasty bits
 # of the EXIF standard
-def process_file(f, stop_tag='UNDEF', details=True, strict=False, debug=False):
-    # yah it's cheesy...
-    global detailed
-    detailed = details
 
-    # by default do not fake an EXIF beginning
-    fake_exif = 0
 
+def process_file(file, debug=0):
     # determine whether it's a JPEG or TIFF
-    data = f.read(12)
+    data = file.read(12)
     if data[0:4] in ['II*\x00', 'MM\x00*']:
         # it's a TIFF file
-        f.seek(0)
-        endian = f.read(1)
-        f.read(1)
+        file.seek(0)
+        endian = file.read(1)
+        file.read(1)
         offset = 0
     elif data[0:2] == '\xFF\xD8':
         # it's a JPEG file
-        while data[2] == '\xFF' and data[6:10] in ('JFIF', 'JFXX', 'OLYM', 'Phot'):
-            length = ord(data[4])*256+ord(data[5])
-            f.read(length-8)
+        # skip JFIF style header(s)
+        fake_exif = 0
+        while data[2] == '\xFF' and data[6:10] in ('JFIF', 'JFXX', 'OLYM'):
+            length = ord(data[4]) * 256 + ord(data[5])
+            file.read(length - 8)
             # fake an EXIF beginning of file
-            data = '\xFF\x00'+f.read(10)
+            data = '\xFF\x00' + file.read(10)
             fake_exif = 1
         if data[2] == '\xFF' and data[6:10] == 'Exif':
             # detected EXIF header
-            offset = f.tell()
-            endian = f.read(1)
+            offset = file.tell()
+            endian = file.read(1)
         else:
             # no EXIF information
             return {}
@@ -1654,9 +1590,8 @@ def process_file(f, stop_tag='UNDEF', details=True, strict=False, debug=False):
 
     # deal with the EXIF info we found
     if debug:
-        print "Endian format is ",endian
-        print {'I': 'Intel', 'M': 'Motorola', '\x01':'Adobe Ducky', 'd':'XMP/Adobe unknown' }[endian], 'format'
-    hdr = EXIF_header(f, endian, offset, fake_exif, strict, debug)
+        print {'I': 'Intel', 'M': 'Motorola'}[endian], 'format'
+    hdr = EXIF_header(file, endian, offset, False, debug)
     ifd_list = hdr.list_IFDs()
     ctr = 0
     for i in ifd_list:
@@ -1669,13 +1604,13 @@ def process_file(f, stop_tag='UNDEF', details=True, strict=False, debug=False):
             IFD_name = 'IFD %d' % ctr
         if debug:
             print ' IFD %d (%s) at offset %d:' % (ctr, IFD_name, i)
-        hdr.dump_IFD(i, IFD_name, stop_tag=stop_tag)
+        hdr.dump_IFD(i, IFD_name)
         # EXIF IFD
-        exif_off = hdr.tags.get(IFD_name+' ExifOffset')
+        exif_off = hdr.tags.get(IFD_name + ' ExifOffset')
         if exif_off:
             if debug:
                 print ' EXIF SubIFD at offset %d:' % exif_off.values[0]
-            hdr.dump_IFD(exif_off.values[0], 'EXIF', stop_tag=stop_tag)
+            hdr.dump_IFD(exif_off.values[0], 'EXIF')
             # Interoperability IFD contained in EXIF IFD
             intr_off = hdr.tags.get('EXIF SubIFD InteroperabilityOffset')
             if intr_off:
@@ -1683,13 +1618,13 @@ def process_file(f, stop_tag='UNDEF', details=True, strict=False, debug=False):
                     print ' EXIF Interoperability SubSubIFD at offset %d:' \
                           % intr_off.values[0]
                 hdr.dump_IFD(intr_off.values[0], 'EXIF Interoperability',
-                             dict=INTR_TAGS, stop_tag=stop_tag)
+                             dict=INTR_TAGS)
         # GPS IFD
-        gps_off = hdr.tags.get(IFD_name+' GPSInfo')
+        gps_off = hdr.tags.get(IFD_name + ' GPSInfo')
         if gps_off:
             if debug:
                 print ' GPS SubIFD at offset %d:' % gps_off.values[0]
-            hdr.dump_IFD(gps_off.values[0], 'GPS', dict=GPS_TAGS, stop_tag=stop_tag)
+            hdr.dump_IFD(gps_off.values[0], 'GPS', dict=GPS_TAGS)
         ctr += 1
 
     # extract uncompressed TIFF thumbnail
@@ -1700,81 +1635,47 @@ def process_file(f, stop_tag='UNDEF', details=True, strict=False, debug=False):
     # JPEG thumbnail (thankfully the JPEG data is stored as a unit)
     thumb_off = hdr.tags.get('Thumbnail JPEGInterchangeFormat')
     if thumb_off:
-        f.seek(offset+thumb_off.values[0])
+        file.seek(offset + thumb_off.values[0])
         size = hdr.tags['Thumbnail JPEGInterchangeFormatLength'].values[0]
-        hdr.tags['JPEGThumbnail'] = f.read(size)
+        hdr.tags['JPEGThumbnail'] = file.read(size)
 
     # deal with MakerNote contained in EXIF IFD
-    # (Some apps use MakerNote tags but do not use a format for which we
-    # have a description, do not process these).
-    if 'EXIF MakerNote' in hdr.tags and 'Image Make' in hdr.tags and detailed:
+    if hdr.tags.has_key('EXIF MakerNote'):
         hdr.decode_maker_note()
 
     # Sometimes in a TIFF file, a JPEG thumbnail is hidden in the MakerNote
     # since it's not allowed in a uncompressed TIFF IFD
-    if 'JPEGThumbnail' not in hdr.tags:
-        thumb_off=hdr.tags.get('MakerNote JPEGThumbnail')
+    if not hdr.tags.has_key('JPEGThumbnail'):
+        thumb_off = hdr.tags.get('MakerNote JPEGThumbnail')
         if thumb_off:
-            f.seek(offset+thumb_off.values[0])
-            hdr.tags['JPEGThumbnail']=file.read(thumb_off.field_length)
+            file.seek(offset + thumb_off.values[0])
+            hdr.tags['JPEGThumbnail'] = file.read(thumb_off.field_length)
 
     return hdr.tags
 
-
-# show command line usage
-def usage(exit_status):
-    msg = 'Usage: EXIF.py [OPTIONS] file1 [file2 ...]\n'
-    msg += 'Extract EXIF information from digital camera image files.\n\nOptions:\n'
-    msg += '-q --quick   Do not process MakerNotes.\n'
-    msg += '-t TAG --stop-tag TAG   Stop processing when this tag is retrieved.\n'
-    msg += '-s --strict   Run in strict mode (stop on errors).\n'
-    msg += '-d --debug   Run in debug mode (display extra info).\n'
-    print msg
-    sys.exit(exit_status)
-
 # library test/debug function (dump given files)
 if __name__ == '__main__':
     import sys
-    import getopt
-
-    # parse command line options/arguments
-    try:
-        opts, args = getopt.getopt(sys.argv[1:], "hqsdt:v", ["help", "quick", "strict", "debug", "stop-tag="])
-    except getopt.GetoptError:
-        usage(2)
-    if args == []:
-        usage(2)
-    detailed = True
-    stop_tag = 'UNDEF'
-    debug = False
-    strict = False
-    for o, a in opts:
-        if o in ("-h", "--help"):
-            usage(0)
-        if o in ("-q", "--quick"):
-            detailed = False
-        if o in ("-t", "--stop-tag"):
-            stop_tag = a
-        if o in ("-s", "--strict"):
-            strict = True
-        if o in ("-d", "--debug"):
-            debug = True
-
-    # output info for each file
-    for filename in args:
+
+    if len(sys.argv) < 2:
+        print 'Usage: %s files...\n' % sys.argv[0]
+        sys.exit(0)
+
+    for filename in sys.argv[1:]:
         try:
-            file=open(filename, 'rb')
+            file = open(filename, 'rb')
         except:
-            print "'%s' is unreadable\n"%filename
+            print filename, 'unreadable'
+            print
             continue
         print filename + ':'
-        # get the tags
-        data = process_file(file, stop_tag=stop_tag, details=detailed, strict=strict, debug=debug)
+        # data=process_file(file, 1) # with debug info
+        data = process_file(file)
         if not data:
             print 'No EXIF information found'
             continue
 
-        x=data.keys()
+        x = data.keys()
         x.sort()
         for i in x:
             if i in ('JPEGThumbnail', 'TIFFThumbnail'):
@@ -1784,7 +1685,10 @@ if __name__ == '__main__':
                       (i, FIELD_TYPES[data[i].field_type][2], data[i].printable)
             except:
                 print 'error', i, '"', data[i], '"'
-        if 'JPEGThumbnail' in data:
+        if data.has_key('JPEGThumbnail'):
             print 'File has JPEG thumbnail'
         print
 
+        f = open('thumb', 'w')
+        f.write(data['JPEGThumbnail'])
+        f.close
-- 
2.15.0

